// vim: set noet ts=2 sw=2:
//
// Cuboid route

// (1) The shortest path from S to F intersects the longest edge in the cube. So
// if the cube's dimensions are X, Y, Z, where X >= Y >= Z, then the shortest
// path from S to F intersects X.
//
// (2) The point of intersection on that edge, X, bisects that edge to create
// two line segments, one length X * Y / (Y + Z) and the other with length X * Z
// / (Y + Z).
//
// I don't know why #1 and #2 are true, but if using them one may reduce the
// length calculation such that LEN = sqrt(A^2 + B^2), where A = Y + Z and B =
// X. Thus, finding integer lengths is finding integer-length hypotenuses, C,
// where A^2 + B^2 = C^2. So this problem is really all about generating
// Pythagorean triples and carefully counting all the possible cuboids.

import std.algorithm;
import std.stdio;
import factor;
import std.stdio;

void main() {

	int cnts[];

	struct SavedTriple {
		long aBase;
		long bBase;
		long cBase;
		long a;
		long b;
		long c;
	}
	SavedTriple[] savedTriples;

	void actOnTriple(long a, long b, long c) {
		//writeln("\t", a, "\t", b, "\t", c);
		// for all x, where x == a:
		while (cnts.length <= a)
			cnts ~= 0;
		cnts[a] += b / 2;
		//writeln("\t\tx=", a, ": ", b / 2);
		// for all x, where x == b:
		if ((a + 1) / 2 <= b) {
			//writeln("\t\tx=", b, ": ", min(a + 1, b) - (a + 1) / 2 + 1);
			cnts[b] += min(a + 1, b) - (a + 1) / 2 + 1;
		} 
	}

	// a = m^2 - n^2
	// b = 2mn
	// c = m^2 + n^2
	//
	// The triple generated by m and n is primitive if and only if m and n are
	// coprime and (m - 2) is odd.

	long total;
	long m = 2;
	long M = 2;
	while (true) {
		long n;
		for (n = 1; n < m; n++) {
			long a = m * m - n * n;
			long b = 2 * m * n;
			long c = m * m + n * n;
			if ((m - n) % 2 == 1 && gcd(m, n) == 1) {
				if (a < b) { swap(a, b); }
				savedTriples ~= SavedTriple(a, b, c, 2 * a, 2 * b, 2 * c);
				actOnTriple(a, b, c);
			}
			if (n + 1 == m) {
				foreach (i, triple; savedTriples) {
					if (triple.b > M && triple.b <= b) {
						actOnTriple(triple.a, triple.b, triple.c);
						savedTriples[i].a += triple.aBase;
						savedTriples[i].b += triple.bBase;
						savedTriples[i].c += triple.cBase;
					}
				}
				do {
					M++;
					total += cnts[M];
					//writeln(M, "\t", total);
					if (total > 1_000_000) {
						goto done;
					}
				} while (M < b);
			}
		}
		m++;
	}

done:

	writeln(M);
}

